{"title":"Decoding a UTF-8 Hex String Into It's Unicode Code Print","markdown":{"yaml":{"title":"Decoding a UTF-8 Hex String Into It's Unicode Code Print","author":"Santiago Torres","date":"2025-04-05","toc":true,"title-block-banner":true},"headingText":"UTF-8 Decoding of Unicode","containsRefs":false,"markdown":"\n\n\nThis program decodes a UTF-8 string and returns it's corresponding\nUnicode code point (Ex: the string 0xCE, 0xA9 returns `U+03A9`).\nThe goal for this program is to explain the concept of UTF-8 and\nthe process of decoding a UTF-8 string into a Unicode character\nat the bit level.\n\n## Background\nUTF-8 is an encoding standard that is used for electronic communication.\nIt is most commonly used for encoding characters, using a variable-length\nencoding ranging from one to four bytes. It is an extention to the original\nASCII standard and it is also backwards compatible. There was also another\nencoding aimed to extend ASCII known as ISO/IEC 8859, however, it was\nquickly taken over by UTF-8 due to it's fragmented design. The problem\nwith ISO 8859 was that it had different versions for specific regions,\nwhich made it impossible to mix different languages in one document.\n\n## Decoding Process\nTo begin decoding, we must convert our string to binary\nand then combine them into 8-bit chunks. This is not done\nin the code, but it is shown here to demonstrate the concept.\nEx: CEA9\n\n```\n0xCE        0xA9\n1100 1110   1010 1001\n11001110    10101001\n```\n\nThe first byte is very important. It will determine how many bytes there are in the string.\nThis will be necessary to determine the number of continuation bits.\nHere is a chart which shows the number of bytes in the string as determined by the first bit.\n\n| First Byte  | bytes   |\n|------------:|--------:|\n| 0 xxxxxxx   | 1       |\n| 110 xxxxx   | 2       |\n| 1110 xxxx   | 3       |\n| 11110 xxx   | 4       |\n\nHere are the conditions in the code to check for this at the bit level\n```c\nif      (0x00 <= value && value <= 0x7F)    retval = 1;\nelse if (0xC0 <= value && value <= 0xDF)    retval = 2;\nelse if (0xE0 <= value && value <= 0xEF)    retval = 3;\nelse if (0xF0 <= value && value <= 0xF7)    retval = 4;\nelse                                        retval = 0;\n\nreturn retval;\n```\n\nIn this case, the first byte is prefixed with 110\n```\n1100 - 1110    10 - 101001\n```\n\nNotice that the last byte is prefixed with 10. This is a continuation byte.\nEvery continuation byte is prefixed with 10. In the program, we use the following\nconditon to check if the continuation bits are valid. But first, we must eliminate\nthe framing bits from the first byte, which in this case are 110x - xxxx.\nThe following conditions is used to do this.\n\n```c\nif      (0x00 <= value && value <= 0x7F)    retval = value;\nelse if (0xC0 <= value && value <= 0xDF)    retval = value & 0x1F;\nelse if (0xE0 <= value && value <= 0xEF)    retval = value & 0xF;\nelse if (0xF0 <= value && value <= 0xF7)    retval = value & 0x7;\nelse                                        retval = 0;\n\nreturn retval;\n\nsum += bytes[0];    // this is done outside of the function\n                    // once the framing bits are eliminated.\n```\n\nand to check if the continuation bytes are valid\n\n```c\nvalue = value & 0xC0;   // apply a bitwise AND to only keep the 10 in 10xx xxxx\nif (value == 0x80) retval = 1;\nreturn retval;\n```\n\nFinally, we removing the framing bits from the continuation bytes\nand sum all of the bytes, which will equal our Unicode character in hexadecimal.\n\n```c\n// removing framing bits\nbytes[i] = bytes[i] & 0x3F;\n\n// add to sum\nsum = sum << 6;     // apply a left-shift operation to easily add the bits to the sum\nsum += bytes[i];    // add the bits to the sum\n```\n\nNow we get our final value\n```\n1110 101001\nU+03A9\n```\n","srcMarkdownNoYaml":"\n\n# UTF-8 Decoding of Unicode\n\nThis program decodes a UTF-8 string and returns it's corresponding\nUnicode code point (Ex: the string 0xCE, 0xA9 returns `U+03A9`).\nThe goal for this program is to explain the concept of UTF-8 and\nthe process of decoding a UTF-8 string into a Unicode character\nat the bit level.\n\n## Background\nUTF-8 is an encoding standard that is used for electronic communication.\nIt is most commonly used for encoding characters, using a variable-length\nencoding ranging from one to four bytes. It is an extention to the original\nASCII standard and it is also backwards compatible. There was also another\nencoding aimed to extend ASCII known as ISO/IEC 8859, however, it was\nquickly taken over by UTF-8 due to it's fragmented design. The problem\nwith ISO 8859 was that it had different versions for specific regions,\nwhich made it impossible to mix different languages in one document.\n\n## Decoding Process\nTo begin decoding, we must convert our string to binary\nand then combine them into 8-bit chunks. This is not done\nin the code, but it is shown here to demonstrate the concept.\nEx: CEA9\n\n```\n0xCE        0xA9\n1100 1110   1010 1001\n11001110    10101001\n```\n\nThe first byte is very important. It will determine how many bytes there are in the string.\nThis will be necessary to determine the number of continuation bits.\nHere is a chart which shows the number of bytes in the string as determined by the first bit.\n\n| First Byte  | bytes   |\n|------------:|--------:|\n| 0 xxxxxxx   | 1       |\n| 110 xxxxx   | 2       |\n| 1110 xxxx   | 3       |\n| 11110 xxx   | 4       |\n\nHere are the conditions in the code to check for this at the bit level\n```c\nif      (0x00 <= value && value <= 0x7F)    retval = 1;\nelse if (0xC0 <= value && value <= 0xDF)    retval = 2;\nelse if (0xE0 <= value && value <= 0xEF)    retval = 3;\nelse if (0xF0 <= value && value <= 0xF7)    retval = 4;\nelse                                        retval = 0;\n\nreturn retval;\n```\n\nIn this case, the first byte is prefixed with 110\n```\n1100 - 1110    10 - 101001\n```\n\nNotice that the last byte is prefixed with 10. This is a continuation byte.\nEvery continuation byte is prefixed with 10. In the program, we use the following\nconditon to check if the continuation bits are valid. But first, we must eliminate\nthe framing bits from the first byte, which in this case are 110x - xxxx.\nThe following conditions is used to do this.\n\n```c\nif      (0x00 <= value && value <= 0x7F)    retval = value;\nelse if (0xC0 <= value && value <= 0xDF)    retval = value & 0x1F;\nelse if (0xE0 <= value && value <= 0xEF)    retval = value & 0xF;\nelse if (0xF0 <= value && value <= 0xF7)    retval = value & 0x7;\nelse                                        retval = 0;\n\nreturn retval;\n\nsum += bytes[0];    // this is done outside of the function\n                    // once the framing bits are eliminated.\n```\n\nand to check if the continuation bytes are valid\n\n```c\nvalue = value & 0xC0;   // apply a bitwise AND to only keep the 10 in 10xx xxxx\nif (value == 0x80) retval = 1;\nreturn retval;\n```\n\nFinally, we removing the framing bits from the continuation bytes\nand sum all of the bytes, which will equal our Unicode character in hexadecimal.\n\n```c\n// removing framing bits\nbytes[i] = bytes[i] & 0x3F;\n\n// add to sum\nsum = sum << 6;     // apply a left-shift operation to easily add the bits to the sum\nsum += bytes[i];    // add the bits to the sum\n```\n\nNow we get our final value\n```\n1110 101001\nU+03A9\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.21","theme":["slate"],"title":"Decoding a UTF-8 Hex String Into It's Unicode Code Print","author":"Santiago Torres","date":"2025-04-05","title-block-banner":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}