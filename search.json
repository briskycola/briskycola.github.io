[
  {
    "objectID": "posts/setting-up-k8s-with-custom-images/index.html",
    "href": "posts/setting-up-k8s-with-custom-images/index.html",
    "title": "Setting up Kubernetes with custom image support on Alpine Linux",
    "section": "",
    "text": "This is a brief post on How I setup Kubernetes on Alpine Linux and deploy my own images."
  },
  {
    "objectID": "posts/setting-up-k8s-with-custom-images/index.html#introduction",
    "href": "posts/setting-up-k8s-with-custom-images/index.html#introduction",
    "title": "Setting up Kubernetes with custom image support on Alpine Linux",
    "section": "",
    "text": "This is a brief post on How I setup Kubernetes on Alpine Linux and deploy my own images."
  },
  {
    "objectID": "posts/setting-up-k8s-with-custom-images/index.html#prerequisites",
    "href": "posts/setting-up-k8s-with-custom-images/index.html#prerequisites",
    "title": "Setting up Kubernetes with custom image support on Alpine Linux",
    "section": "Prerequisites",
    "text": "Prerequisites\nYou must have at least 2 computers or virtual machines, one as the control plane and the other as the worker node.\n\nSetting up the edge repos (control plane and worker)\nTo install Docker and Kubernetes on Alpine, you must setup the Alpine Linux edge repo. To do this, add the following lines to /etc/apk/repositories\nhttp://dl-cdn.alpinelinux.org/alpine/edge/community\nhttp://dl-cdn.alpinelinux.org/alpine/edge/testing\nThen run doas apk update && doas apk upgrade\n\n\nSetting up necessary kernel modules (control plane and worker)\nIn order to have the kubernetes network functioning, you must add the br_netfilter kernel module and add some rules to sysctl. To do this, run the following commands as root:\necho \"br_netfilter\" &gt; /etc/modules-load.d/k8s.conf\necho \"net.ipv4.ip_forward=1\" &gt;&gt; /etc/sysctl.conf\necho \"net.bridge.bridge-nf-call-iptables=1\" &gt;&gt; /etc/sysctl.conf\nmodprobe br_netfilter\nsysctl net.ipv4.ip_forward=1\nsysctl net.bridge.bridge-nf-call-iptables=1"
  },
  {
    "objectID": "posts/setting-up-k8s-with-custom-images/index.html#installing-docker",
    "href": "posts/setting-up-k8s-with-custom-images/index.html#installing-docker",
    "title": "Setting up Kubernetes with custom image support on Alpine Linux",
    "section": "Installing Docker",
    "text": "Installing Docker\n\nInstalling Packages (control plane and worker)\nTo get docker running on Alpine, you must install the following packages and enable the following services as root:\napk add docker docker-cli-buildx docker-cli-compose\nrc-update add docker\nrc-update add containerd\nrc-service docker start\nrc-service containerd start\nIf you want to use Docker with an unprivileged user, you need to add your user to the Docker group. To do this, run as root:\naddgroup $USER docker\nYou will have to restart your computer after this change.\n\n\nSetting up local Docker Registry (control plane)\nIf you want to use your own Docker images, you will have to host your own Docker registry. Before we do that, we need to create an SSL certificate for secure connectivity.\nmkdir -p registry/certs\nopenssl genpkey -algorithm ed25519 -out registry.key\nopenssl req -new -x509 -key registry.key -out registry.crt \\\n    -days 365 \\\n    -subj \"/C=US/ST=California/L=Los Angeles/O=Not Money Laundering LLC/OU=Briskycola/CN=Briskycola\" \\\n    -addext \"subjectAltName = IP:&lt;your-server-ip&gt;\"\nIn order for Docker to trust this certificate, you will have to manually add it to your ca-certificates folder. To do this, run the following commands as root:\ndoas cp certs/registry.* /usr/local/share/ca-certificates/\ndoas update-ca-certificates\nYou will need to restart your computer after these changes. Additionally, you will have to copy the registry certificates on your worker nodes and update the ca-certificates\nNow to create the docker registry, we will use the a Docker Compose yaml to download the registry image and host it with the appropriate settings. Here is a command that will create the conf file\ncd ../\nSECRET=$(openssl rand -hex 32)\ntee &lt;&lt;EOF compose.yml\nservices:\n    registry:\n        image: registry:3\n        container_name: registry\n        restart: always\n        ports:\n            - \"5000:5000\"\n        volumes:\n            - ./certs:/certs\n            - ./data:/var/lib/registry\n        environment:\n            REGISTRY_HTTP_SECRET: $SECRET\n            REGISTRY_HTTP_TLS_CERTIFICATE: ./certs/registry.crt\n            REGISTRY_HTTP_TLS_KEY: ./certs/registry.key\nEOF\nTo run the registry, run docker-compose up -d\nTo add your custom docker image to the registry, run the following commands:\ndocker tag &lt;your-image-name&gt; &lt;your-ip-address&gt;:5000/&lt;your-image-name&gt;\ndocker push &lt;your-ip-address&gt;:5000/&lt;your-image-name&gt;"
  },
  {
    "objectID": "posts/setting-up-k8s-with-custom-images/index.html#installing-kubernetes",
    "href": "posts/setting-up-k8s-with-custom-images/index.html#installing-kubernetes",
    "title": "Setting up Kubernetes with custom image support on Alpine Linux",
    "section": "Installing Kubernetes",
    "text": "Installing Kubernetes\n\nInstalling packages (control plane and worker)\nRun the following commands as root to install the necessary packages for Kubernetes:\napk add cni-plugin-flannel\napk add cni-plugins\napk add flannel\napk add flannel-contrib-cni\napk add kubelet\napk add kubeadm\napk add kubectl\napk add containerd\napk add uuidgen\napk add nfs-utils\n\n\nDisable Swap\nIn order for Kubernetes to work, you will need to disable swap. It is especially good to disable swap if you’re on an SSD to avoid excees writes and preserve your SSD’s lifespan. Run the following commands as root to disable swap:\ncp -av /etc/fstab /etc/fstab.bak\nsed -i '/swap/s/^/#/' /etc/fstab\nswapoff -a\n\n\nSet Mount Propagation To Be Recursively Shared\nSome services will require mount propagation in order to allow containers and pods to mount sub-volumes and have them be accessible on the host. To allow mount propagation, run the following command:\ndoas mount --make-rshared /\n\n\nEnable services (control plane and worker)\nTo enable kubernetes on boot, run the following commands:\ndoas rc-update add kubelet\ndoas rc-service kubelet start\n\n\nPin Kubernetes Package (control plane and worker)\nTo avoid potential breakage with the kubernetes cluster, it is strongly advised to pin the versions of each package. As of writing this guide, the latest version is 1.33. To pin the packages, run:\ndoas apk add 'kubelet=~1.33'\ndoas apk add 'kubeadm=~1.33'\ndoas apk add 'kubectl=~1.33'\nTo update to a newer version, say 1.34, you will need to run these commands again, but with the newer version.\n\n\nCreate the Kubernetes Cluster (control plane)\nTo create a new kubernetes cluster run the following command:\ndoas kubeadm init --pod-network-cidr=10.244.0.0/16\nThis will take quite some time depending on your computer and network speeds. Once that is done, you can start the cluster by running the following commands:\nmkdir -p $HOME/.kube\ndoas cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\ndoas chown $(id -u):$(id -g) $HOME/.kube/config\nNext you will need to deploy a pod network. I recommend flannel since it’s the easiest to deploy. You can deploy flannel by running the following command:\nkubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml\nIn order for your worker nodes to join your cluster, you must run the following command to output a unique join command:\ndoas kubeadm token create --print-join-command\nYou will have to run the output command on the worker node to allow it to join the cluster.\n\n\nCreate a Deployment and Service (control plane)\nTo create a deployment and a service you can either run kubectl commands or create a yaml file that has the properties that you want. I’ll show you both ways.\n\nCLI\nRun the following commands to create a Deployment and Service\nkubectl create deployment &lt;name&gt; --image=&lt;your-image&gt; --replicas=3                        # Docker Hub image\nkubectl create deployment &lt;name&gt; --image=&lt;your-ip-address&gt;:5000/&lt;your-image&gt; --replicas=3 # Self hosted image\nkubectl create service nodeport &lt;name&gt; --tcp=&lt;external-port&gt;:&lt;container-port&gt; --node-port=&lt;30000-32767&gt;\n\n\nYaml File\nCreate a .yaml or .yml file and use the following template to create your yaml configuration:\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n    name: &lt;name&gt;\nspec:\n    replicas: 3\n    selector:\n        matchLabels:\n            app: &lt;name&gt;\n    template:\n        metadata:\n            labels:\n                app: &lt;name&gt;\n        spec:\n            containers:\n                - name: &lt;name&gt;\n                  image: &lt;image&gt;\n                  ports:\n                      - containerPort: &lt;container-port&gt;\n---\napiVersion: v1\nkind: Service\nmetadata:\n    name: &lt;name&gt;\nspec:\n    selector:\n        app: &lt;name&gt;\n    ports:\n        - name: &lt;name&gt;\n          port: &lt;external-port&gt;\n          targetPort: &lt;container-port&gt;\n          nodePort: &lt;30000-32767&gt;\n    type: NodePort\nTo create a Deployment and Service using your config, run the following command:\nkubectl apply -f &lt;your-file&gt;.yml"
  },
  {
    "objectID": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#introduction",
    "href": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#introduction",
    "title": "How To Setup QEMU/Virt Manager On Linux",
    "section": "Introduction",
    "text": "Introduction\nSometimes, we find ourselves needing to use a different operating system to accomplish a certain task. For example, you are using Linux and you need to run a program designed for Windows, and the program cannot run under a compatibility layer like WINE. Previously on Linux, for these kinds of scenarios, Virtualbox was used to create virtual machines to run these programs, and while Virtualbox is a great program, it’s quite slow in comparison to QEMU with KVM. In my experience, QEMU with KVM acceleration has given me the best performance compared to other software. This guide will show you in detail how to use QEMU along with Virt Manager to make virtual machines with near-native performance."
  },
  {
    "objectID": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#prerequisites",
    "href": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#prerequisites",
    "title": "How To Setup QEMU/Virt Manager On Linux",
    "section": "Prerequisites",
    "text": "Prerequisites\nYou must have virtualization enabled in your BIOS. This is usually enabled by default but if you want to check, you can run the following command:\nlscpu | grep Virtualization\nIf you have an Intel CPU, it should say VT-x and on an AMD CPU, it should say AMD-V. If you don’t see anything. You will have to go into your BIOS and enable it yourself. If you have an Intel motherboard, you should enable VT-x and if you have an AMD motherboard, you should enable AMD-V. Consult your PC manufacturer or motherboard manual for further instructions."
  },
  {
    "objectID": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#installation",
    "href": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#installation",
    "title": "How To Setup QEMU/Virt Manager On Linux",
    "section": "Installation",
    "text": "Installation\nIt is time to install QEMU along with Virt Manager onto your system. Install the following packages using your distribution’s package manager.\nArch Linux\nsudo pacman -S qemu-desktop virt-manager virt-viewer dnsmasq vde2 bridge-utils openbsd-netcat libguestfs\nDebian/Ubuntu\nsudo apt install qemu-system virt-manager libvirt-daemon dnsmasq vde2 bridge-utils netcat-openbsd libguestfs-tools\nFedora\nsudo dnf install @virtualization\n\nNon-systemd distributions\nIf you are using a distribution that does not use systemd, you must install the libvirt daemon package that corresponds to your init system. For example, on an Artix Linux system with OpenRC, you must install libvirt-openrc."
  },
  {
    "objectID": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#modify-configuration-files",
    "href": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#modify-configuration-files",
    "title": "How To Setup QEMU/Virt Manager On Linux",
    "section": "Modify configuration files",
    "text": "Modify configuration files\nBefore we start creating virtual machines, we need to make sure that the user has sufficient permissions to use KVM. To do this, we first need to uncomment the following lines in /etc/libvirt/libvirtd.conf\nunix_sock_group = \"libvirt\"\nunix_sock_ro_perms = \"0777\"\nunix_sock_rw_perms = \"0770\"\nAfter making those changes, your user must be part of the libvirt group, run the following command to make the changes:\nsudo usermod -aG libvirt $(whoami)\nIf you are using a Debian/Ubuntu based distribution, you may need to add your user to the kvm group: run the following command to make the changes:\nsudo usermod -aG kvm $(whoami)\nNow we must enable the libvirtd service itself. On most distributions, you can enable the service on startup using systemd:\nsudo systemctl enable libvirtd\nIf you are using a distribution that does not use systemd, you must enable the service using your distribution’s init system.\nAt this point, you must restart your system for the changes to be applied."
  },
  {
    "objectID": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#setting-up-the-virtual-machine",
    "href": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#setting-up-the-virtual-machine",
    "title": "How To Setup QEMU/Virt Manager On Linux",
    "section": "Setting up the virtual machine",
    "text": "Setting up the virtual machine\nOpen Virt Manager and wait for QEMU/KVM to connect. Before we begin creating a virtual machine, we first must make sure that the virtual network adapter is working. To check this, click on QEMU/KVM, then go to Edit -&gt; Connection Details -&gt; Virtual Networks and click the play button to enable the virtual network adapter. Also make sure to check On Boot to ensure that the adapter is always started.\nNow we can begin the process of creating a virtual machine. Go to File -&gt; New Virtual Machine. Make sure local install media is selected and click forward.\nYou will then be prompted to select an ISO image. Go to Browse -&gt; Browse Local and locate your ISO image. Most of the time, it will automatically detect the OS. If it doesn’t, you will have to manually select the OS.\nAfter that, you’ll be asked to allocate RAM and CPUs to the VM. The general rule for allocating RAM is to never go above 50% of your total RAM (Ex: if you have 16GB of RAM, you can allocate at most 8GB). Ignore the number of CPUs for now, we will configure that later.\nThe next step is to configure your storage. You can configure this however you want.\nNow you will get a message to confirm the VM settings. We are not done with the configuration just yet. We are going to change some of the VM settings. Make sure to check Customize configuration before install and click Finish."
  },
  {
    "objectID": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#customizing-virtual-machine-settings",
    "href": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#customizing-virtual-machine-settings",
    "title": "How To Setup QEMU/Virt Manager On Linux",
    "section": "Customizing virtual machine settings",
    "text": "Customizing virtual machine settings\n\nChanging firmware to UEFI\nWe will start with changing the firmware settings. I personally like to set the firmware to UEFI because every modern computer uses UEFI and many operating systems expect UEFI. This change is optional unless your guest OS requires UEFI.\n\n\nModifying CPU topology\nThe next setting we will change is the CPU. The reason we didn’t allocate CPU cores ahead of time is because for some reason, Virt Manager allocates sockets instead of cores and threads. In other words, the guest OS will think there are multiple physical CPUs. We will modify the topology to allocate cores and threads instead. Similar to allocating RAM, do not go above 50% of your total CPU threads. To view the total threads allocated, look at vCPU allocation\n\n\nChanging disk interface\nNext we will change the disk interface. The VirtIO interface is recommended as it is a paravirtualized interface, which makes it faster compared to using the emulated SATA interface.\n\n\nSelecting graphics adapter\nThere are two options for the graphics adapter. You can use either Virtio or QXL. Virtio has 3D acceleration and QXL only has 2D acceleration. You can use the driver that works best with your use case.\n\n\nAdding a second CD/DVD Drive (Windows Guests Only)\nWindows does not come with VirtIO drivers. Because of this, we need to install the drivers manually during Windows setup. The virtio drivers for Windows can be found here. To add a second CD/DVD drive, go to Add Hardware -&gt; Storage -&gt; change device type to CDROM device -&gt; click Manage and locate the VirtIO drivers.\n\n\nAdding a TPM Module (Windows 11 Guests Only)\nWindows 11 requires a TPM Module in order to be installed. Thankfully, you can emulate a TPM using swtpm. Use your distribution’s package manager to install swtpm. To add the TPM to the VM, go to Add Hardware -&gt; TPM -&gt; and use the default settings."
  },
  {
    "objectID": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#installing-the-operating-system",
    "href": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#installing-the-operating-system",
    "title": "How To Setup QEMU/Virt Manager On Linux",
    "section": "Installing the operating system",
    "text": "Installing the operating system\nNow you can click Begin Installation and from here, install the OS as you would on a physical computer. I’m installing Windows Server 2022. \n\nInstalling VirtIO drivers (Windows Guests Only)\nEarlier I mentioned that we needed to add a second CD/DVD drive for the VirtIO drivers. You may have noticed that Windows didn’t detect the disk. This is where the second CD/DVD drive comes in. To install the drivers, go to Load Driver -&gt; Ok and you will get a list of available drivers. Install the driver that cooresponds to your version of Windows. From here you can continue with the Windows install normally. \n\n\nInstall graphics drivers (Windows Guests Only)\nOnce Windows is fully installed, we will need to install the graphics drivers. In File Explorer, go to the drive labeled as virtio-win-x.x.xxx and run virtio-win-guest-tools.exe"
  },
  {
    "objectID": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#conclusion",
    "href": "posts/how-to-setup-qemu-virt-manager-tutorial/index.html#conclusion",
    "title": "How To Setup QEMU/Virt Manager On Linux",
    "section": "Conclusion",
    "text": "Conclusion\nYou have now successfully created a virtual machine using QEMU/Virt Manager. This VM will have near-native performance with very little emulation overhead. Here is a screenshot of the VM with all of the necessary drivers."
  },
  {
    "objectID": "posts/how-i-got-into-linux/index.html",
    "href": "posts/how-i-got-into-linux/index.html",
    "title": "How I Got Into Linux",
    "section": "",
    "text": "I’m often asked how I got into using Linux and the command line. I’ve known about Linux for a very long time, but only started using it actively for about four years. As I reflect on my experiences, it has been one of the most interesting, frustrating, and rewarding experiences I’ve had."
  },
  {
    "objectID": "posts/how-i-got-into-linux/index.html#introduction",
    "href": "posts/how-i-got-into-linux/index.html#introduction",
    "title": "How I Got Into Linux",
    "section": "",
    "text": "I’m often asked how I got into using Linux and the command line. I’ve known about Linux for a very long time, but only started using it actively for about four years. As I reflect on my experiences, it has been one of the most interesting, frustrating, and rewarding experiences I’ve had."
  },
  {
    "objectID": "posts/how-i-got-into-linux/index.html#first-start",
    "href": "posts/how-i-got-into-linux/index.html#first-start",
    "title": "How I Got Into Linux",
    "section": "First Start",
    "text": "First Start\nI first discovered Linux in 2020 after becoming frustrated with the direction Microsoft was going with Windows. With the telemetry in Windows becoming worse and worse, I was starting to question Microsoft’s plans with the OS and ultimately came to the conclusion that the old days of Windows were over, and it was time to move on. I would sometimes try Linux on my main PC, but would ultimately go back to Windows due to issues with Linux. For example, I would have issues with the Nvidia drivers (they are much better now). Looking back, those issues may have been my fault, but I didn’t know at the time.\nAs a result of my failures using Linux, I began to dislike it. I thought it was a terrible OS and it would never become mainstream. However, the more I thought about it, the more ridiculous it seemed. If Linux was so bad, how could it still be around today, and how could there be so many zealots claiming it was the greatest thing to have ever been conceived by mankind?"
  },
  {
    "objectID": "posts/how-i-got-into-linux/index.html#learning-linux-the-right-way",
    "href": "posts/how-i-got-into-linux/index.html#learning-linux-the-right-way",
    "title": "How I Got Into Linux",
    "section": "Learning Linux (The Right Way)",
    "text": "Learning Linux (The Right Way)\nIn 2022, my high school’s IT department were getting rid of old laptops, and I was able to get one for free. It was a ThinkPad R61 from 2008. Not knowing what to do with the computer, I remembered that I could install Linux on this thing. Windows 10 would have been slow and I could learn Linux while keeping my current PC intact.\nFrom there, I tried all of the easy to use distributions such as Ubuntu, Linux Mint, and Fedora. Eventually, I started to use more advanced distros such as Arch, Artix, and Void. Since I was using a much older computer, I started experimenting with tiling window managers to get a lighter graphical environment. After testing all of these distros, I realized that I liked Arch based distros the best, due to the release cycle, customizability, and wide software selection. These days, I just use Arch. Here is a picture of the laptop running Artix Linux with YouTuber DistroTube’s rice of DWM.\n\n\n\nArtix Linux with DWM (2022)"
  },
  {
    "objectID": "posts/how-i-got-into-linux/index.html#using-linux-as-a-daily-driver",
    "href": "posts/how-i-got-into-linux/index.html#using-linux-as-a-daily-driver",
    "title": "How I Got Into Linux",
    "section": "Using Linux as a daily driver",
    "text": "Using Linux as a daily driver\nIn 2023, when I started my first year of college, I built a new gaming PC to replace my old build from 2017. This was a high-end build, and it has an i5-13600KF, 32GB DDR5 6000 MT/s, and an RX 7900 XT. When I built this PC, I wanted to try Linux on it. Since I had an AMD graphics card, I was going to have a much better experience due to the better drivers. I was already good with Linux, so I installed Arch Linux on a second drive. I kept this setup for a while until I eventually ditched Windows all together and went full Linux. I continue to run this setup to this day and I am able to do any task on Linux, even gaming.\n\n\n\nMy Current PC"
  },
  {
    "objectID": "posts/how-i-got-into-linux/index.html#conclusion",
    "href": "posts/how-i-got-into-linux/index.html#conclusion",
    "title": "How I Got Into Linux",
    "section": "Conclusion",
    "text": "Conclusion\nOverall, I learned a lot from my experience switching to Linux. While there were definitely times it was frustrating, I gained a lot of valuable skills, such as using the command line and troubleshooting skills. This has been my story of how I got into Linux. I hope you enjoyed reading through my journey with Linux."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome!",
    "section": "",
    "text": "Hello, I’m Santiago Torres and this is my website! I’m a Computer Science student with a strong interest in programming, cybersecurity, and Linux. I’ve always been fascinated by how technology works and how different systems interact with each other. Through my studies, I’ve gained a solid foundation in various programming languages and software development practices. I’m particularly passionate about cybersecurity, constantly exploring ways to protect and secure various different systems. Additionally, I enjoy working with Linux, which has broadened my understanding of operating systems and system-level programming. This website serves as a collection of my projects, guides, and experiences as I continue to learn and grow in these fields. I hope to not only improve my technical skills but also contribute to the larger tech community in the future."
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Welcome!",
    "section": "",
    "text": "Hello, I’m Santiago Torres and this is my website! I’m a Computer Science student with a strong interest in programming, cybersecurity, and Linux. I’ve always been fascinated by how technology works and how different systems interact with each other. Through my studies, I’ve gained a solid foundation in various programming languages and software development practices. I’m particularly passionate about cybersecurity, constantly exploring ways to protect and secure various different systems. Additionally, I enjoy working with Linux, which has broadened my understanding of operating systems and system-level programming. This website serves as a collection of my projects, guides, and experiences as I continue to learn and grow in these fields. I hope to not only improve my technical skills but also contribute to the larger tech community in the future."
  },
  {
    "objectID": "index.html#website-structure",
    "href": "index.html#website-structure",
    "title": "Welcome!",
    "section": "Website Structure",
    "text": "Website Structure\nThis website serves as a repository for my blogs, guides, and projects\nThe Blogs are where I document my experiences with different kinds of hardware and software.\nThe Guides are my tutorials on various differnent technologies I am interested in. For example, I did a tutorial on how to setup QEMU/Virt Manager on any Linux distribution.\nThe Projects are where I showcase programs that I have written. Some of them are pretty simple while others are more detailed."
  },
  {
    "objectID": "posts/decode-utf8/index.html",
    "href": "posts/decode-utf8/index.html",
    "title": "Decoding a UTF-8 Hex String Into It’s Unicode Code Print",
    "section": "",
    "text": "This program decodes a UTF-8 string and returns it’s corresponding Unicode code point (Ex: the string 0xCE, 0xA9 returns U+03A9). The goal for this program is to explain the concept of UTF-8 and the process of decoding a UTF-8 string into a Unicode character at the bit level.\n\n\nUTF-8 is an encoding standard that is used for electronic communication. It is most commonly used for encoding characters, using a variable-length encoding ranging from one to four bytes. It is an extention to the original ASCII standard and it is also backwards compatible. There was also another encoding aimed to extend ASCII known as ISO/IEC 8859, however, it was quickly taken over by UTF-8 due to it’s fragmented design. The problem with ISO 8859 was that it had different versions for specific regions, which made it impossible to mix different languages in one document.\n\n\n\nTo begin decoding, we must convert our string to binary and then combine them into 8-bit chunks. This is not done in the code, but it is shown here to demonstrate the concept. Ex: CEA9\n0xCE        0xA9\n1100 1110   1010 1001\n11001110    10101001\nThe first byte is very important. It will determine how many bytes there are in the string. This will be necessary to determine the number of continuation bits. Here is a chart which shows the number of bytes in the string as determined by the first bit.\n\n\n\nFirst Byte\nbytes\n\n\n\n\n0 xxxxxxx\n1\n\n\n110 xxxxx\n2\n\n\n1110 xxxx\n3\n\n\n11110 xxx\n4\n\n\n\nHere are the conditions in the code to check for this at the bit level\n#define UTF8_BYTE_ONE_MIN   0x00\n#define UTF8_BYTE_ONE_MAX   0x7F\n#define UTF8_BYTE_TWO_MIN   0xC0\n#define UTF8_BYTE_TWO_MAX   0xDF\n#define UTF8_BYTE_THREE_MIN 0xE0\n#define UTF8_BYTE_THREE_MAX 0xEF\n#define UTF8_BYTE_FOUR_MIN  0xF0\n#define UTF8_BYTE_FOUR_MAX  0xF7\n\nuint8_t returnValue;\nif      (UTF8_BYTE_ONE_MIN &lt;= value && value &lt;= UTF8_BYTE_ONE_MAX)        returnValue = 1;\nelse if (UTF8_BYTE_TWO_MIN &lt;= value && value &lt;= UTF8_BYTE_TWO_MAX)        returnValue = 2;\nelse if (UTF8_BYTE_THREE_MIN &lt;= value && value &lt;= UTF8_BYTE_THREE_MAX)    returnValue = 3;\nelse if (UTF8_BYTE_FOUR_MIN &lt;= value && value &lt;= UTF8_BYTE_FOUR_MAX)      returnValue = 4;\nelse                                                                      returnValue = 0;\nreturn returnValue;\nIn this case, the first byte is prefixed with 110\n1100 - 1110    10 - 101001\nNotice that the last byte is prefixed with 10. This is a continuation byte. Every continuation byte is prefixed with 10. In the program, we use the following conditon to check if the continuation bits are valid. But first, we must eliminate the framing bits from the first byte, which in this case are 110x - xxxx. The following conditions is used to do this.\n#define UTF8_BYTE_ONE_MIN   0x00\n#define UTF8_BYTE_ONE_MAX   0x7F\n#define UTF8_BYTE_TWO_MIN   0xC0\n#define UTF8_BYTE_TWO_MAX   0xDF\n#define UTF8_BYTE_THREE_MIN 0xE0\n#define UTF8_BYTE_THREE_MAX 0xEF\n#define UTF8_BYTE_FOUR_MIN  0xF0\n#define UTF8_BYTE_FOUR_MAX  0xF7\n\nuint8_t returnValue;\nif      (UTF8_BYTE_ONE_MIN &lt;= value && value &lt;= UTF8_BYTE_ONE_MAX)        returnValue = value;\nelse if (UTF8_BYTE_TWO_MIN &lt;= value && value &lt;= UTF8_BYTE_TWO_MAX)        returnValue = value & UTF8_BYTE_TWO_MASK;\nelse if (UTF8_BYTE_THREE_MIN &lt;= value && value &lt;= UTF8_BYTE_THREE_MAX)    returnValue = value & UTF8_BYTE_THREE_MASK;\nelse if (UTF8_BYTE_FOUR_MIN &lt;= value && value &lt;= UTF8_BYTE_FOUR_MAX)      returnValue = value & UTF8_BYTE_FOUR_MASK;\nelse                                                                      returnValue = 0;\nreturn returnValue;\n\nsum += bytes[0];    // this is done outside of the function\n                    // once the framing bits are eliminated.\nand to check if the continuation bytes are valid\n// apply a bitwise AND to only keep the 10 in 10xx xxxx\n// and then return 0 or 1\n#define UTF8_DATA_BIT_MASK         0xC0\n#define UTF8_CONTINUATION_BIT_MASK 0x80\nreturn ((value & UTF8_DATA_BIT_MASK) == UTF8_CONTINUATION_BIT_MASK);\nFinally, we removing the framing bits from the continuation bytes and sum all of the bytes, which will equal our Unicode character in hexadecimal.\n#define UTF8_FRAMING_BIT_MASK 0x3F\n#define UTF8_SHIFT_LENGTH     0x06\n\n// removing framing bits\nbytes[i] = bytes[i] & UTF8_FRAMING_BIT_MASK;\n\n// add to sum\nsum = sum &lt;&lt; UTF8_SHIFT_LENGTH; // apply a left-shift operation to easily add the bits to the sum\nsum += bytes[i];                // add the bits to the sum\nNow we get our final value\n1110 101001\nU+03A9"
  },
  {
    "objectID": "posts/decode-utf8/index.html#background",
    "href": "posts/decode-utf8/index.html#background",
    "title": "Decoding a UTF-8 Hex String Into It’s Unicode Code Print",
    "section": "",
    "text": "UTF-8 is an encoding standard that is used for electronic communication. It is most commonly used for encoding characters, using a variable-length encoding ranging from one to four bytes. It is an extention to the original ASCII standard and it is also backwards compatible. There was also another encoding aimed to extend ASCII known as ISO/IEC 8859, however, it was quickly taken over by UTF-8 due to it’s fragmented design. The problem with ISO 8859 was that it had different versions for specific regions, which made it impossible to mix different languages in one document."
  },
  {
    "objectID": "posts/decode-utf8/index.html#decoding-process",
    "href": "posts/decode-utf8/index.html#decoding-process",
    "title": "Decoding a UTF-8 Hex String Into It’s Unicode Code Print",
    "section": "",
    "text": "To begin decoding, we must convert our string to binary and then combine them into 8-bit chunks. This is not done in the code, but it is shown here to demonstrate the concept. Ex: CEA9\n0xCE        0xA9\n1100 1110   1010 1001\n11001110    10101001\nThe first byte is very important. It will determine how many bytes there are in the string. This will be necessary to determine the number of continuation bits. Here is a chart which shows the number of bytes in the string as determined by the first bit.\n\n\n\nFirst Byte\nbytes\n\n\n\n\n0 xxxxxxx\n1\n\n\n110 xxxxx\n2\n\n\n1110 xxxx\n3\n\n\n11110 xxx\n4\n\n\n\nHere are the conditions in the code to check for this at the bit level\n#define UTF8_BYTE_ONE_MIN   0x00\n#define UTF8_BYTE_ONE_MAX   0x7F\n#define UTF8_BYTE_TWO_MIN   0xC0\n#define UTF8_BYTE_TWO_MAX   0xDF\n#define UTF8_BYTE_THREE_MIN 0xE0\n#define UTF8_BYTE_THREE_MAX 0xEF\n#define UTF8_BYTE_FOUR_MIN  0xF0\n#define UTF8_BYTE_FOUR_MAX  0xF7\n\nuint8_t returnValue;\nif      (UTF8_BYTE_ONE_MIN &lt;= value && value &lt;= UTF8_BYTE_ONE_MAX)        returnValue = 1;\nelse if (UTF8_BYTE_TWO_MIN &lt;= value && value &lt;= UTF8_BYTE_TWO_MAX)        returnValue = 2;\nelse if (UTF8_BYTE_THREE_MIN &lt;= value && value &lt;= UTF8_BYTE_THREE_MAX)    returnValue = 3;\nelse if (UTF8_BYTE_FOUR_MIN &lt;= value && value &lt;= UTF8_BYTE_FOUR_MAX)      returnValue = 4;\nelse                                                                      returnValue = 0;\nreturn returnValue;\nIn this case, the first byte is prefixed with 110\n1100 - 1110    10 - 101001\nNotice that the last byte is prefixed with 10. This is a continuation byte. Every continuation byte is prefixed with 10. In the program, we use the following conditon to check if the continuation bits are valid. But first, we must eliminate the framing bits from the first byte, which in this case are 110x - xxxx. The following conditions is used to do this.\n#define UTF8_BYTE_ONE_MIN   0x00\n#define UTF8_BYTE_ONE_MAX   0x7F\n#define UTF8_BYTE_TWO_MIN   0xC0\n#define UTF8_BYTE_TWO_MAX   0xDF\n#define UTF8_BYTE_THREE_MIN 0xE0\n#define UTF8_BYTE_THREE_MAX 0xEF\n#define UTF8_BYTE_FOUR_MIN  0xF0\n#define UTF8_BYTE_FOUR_MAX  0xF7\n\nuint8_t returnValue;\nif      (UTF8_BYTE_ONE_MIN &lt;= value && value &lt;= UTF8_BYTE_ONE_MAX)        returnValue = value;\nelse if (UTF8_BYTE_TWO_MIN &lt;= value && value &lt;= UTF8_BYTE_TWO_MAX)        returnValue = value & UTF8_BYTE_TWO_MASK;\nelse if (UTF8_BYTE_THREE_MIN &lt;= value && value &lt;= UTF8_BYTE_THREE_MAX)    returnValue = value & UTF8_BYTE_THREE_MASK;\nelse if (UTF8_BYTE_FOUR_MIN &lt;= value && value &lt;= UTF8_BYTE_FOUR_MAX)      returnValue = value & UTF8_BYTE_FOUR_MASK;\nelse                                                                      returnValue = 0;\nreturn returnValue;\n\nsum += bytes[0];    // this is done outside of the function\n                    // once the framing bits are eliminated.\nand to check if the continuation bytes are valid\n// apply a bitwise AND to only keep the 10 in 10xx xxxx\n// and then return 0 or 1\n#define UTF8_DATA_BIT_MASK         0xC0\n#define UTF8_CONTINUATION_BIT_MASK 0x80\nreturn ((value & UTF8_DATA_BIT_MASK) == UTF8_CONTINUATION_BIT_MASK);\nFinally, we removing the framing bits from the continuation bytes and sum all of the bytes, which will equal our Unicode character in hexadecimal.\n#define UTF8_FRAMING_BIT_MASK 0x3F\n#define UTF8_SHIFT_LENGTH     0x06\n\n// removing framing bits\nbytes[i] = bytes[i] & UTF8_FRAMING_BIT_MASK;\n\n// add to sum\nsum = sum &lt;&lt; UTF8_SHIFT_LENGTH; // apply a left-shift operation to easily add the bits to the sum\nsum += bytes[i];                // add the bits to the sum\nNow we get our final value\n1110 101001\nU+03A9"
  },
  {
    "objectID": "posts/how-to-install-void-linux-with-encryption/index.html",
    "href": "posts/how-to-install-void-linux-with-encryption/index.html",
    "title": "How To Install Void Linux with LUKS + KDE + PipeWire (unfinished)",
    "section": "",
    "text": "Void Linux is one of the most unique Linux distros that I’ve encountered. What makes Void Linux unique is that it’s a completely independent distro that is not a fork of any mainstream distro. It is a stable rolling release, which ensures that you get up to date packages without worrying about system-breaking updates. Void Linux also uses runit as the init system, which strongly emphasizes the Unix Philosophy. You also get the choice to choose either musl or glibc as your C library. This guide will show you how to manually install Void Linux with LUKS and the KDE Desktop Environment."
  },
  {
    "objectID": "posts/how-to-install-void-linux-with-encryption/index.html#introduction",
    "href": "posts/how-to-install-void-linux-with-encryption/index.html#introduction",
    "title": "How To Install Void Linux with LUKS + KDE + PipeWire (unfinished)",
    "section": "",
    "text": "Void Linux is one of the most unique Linux distros that I’ve encountered. What makes Void Linux unique is that it’s a completely independent distro that is not a fork of any mainstream distro. It is a stable rolling release, which ensures that you get up to date packages without worrying about system-breaking updates. Void Linux also uses runit as the init system, which strongly emphasizes the Unix Philosophy. You also get the choice to choose either musl or glibc as your C library. This guide will show you how to manually install Void Linux with LUKS and the KDE Desktop Environment."
  },
  {
    "objectID": "posts/how-to-install-void-linux-with-encryption/index.html#prerequisites",
    "href": "posts/how-to-install-void-linux-with-encryption/index.html#prerequisites",
    "title": "How To Install Void Linux with LUKS + KDE + PipeWire (unfinished)",
    "section": "Prerequisites",
    "text": "Prerequisites\nYou must have a computer that supports UEFI. Any computer from 2012-present should be fine. This guide is primarily designed for UEFI computers, but I will update this guide with Legacy BIOS commands whenever I have time."
  },
  {
    "objectID": "posts/how-to-install-void-linux-with-encryption/index.html#preparing-the-live-usb",
    "href": "posts/how-to-install-void-linux-with-encryption/index.html#preparing-the-live-usb",
    "title": "How To Install Void Linux with LUKS + KDE + PipeWire (unfinished)",
    "section": "Preparing the live USB",
    "text": "Preparing the live USB\nAs with any Linux distro, we need to flash an ISO image to a USB drive. You can download the Void Linux ISO from https://repo-default.voidlinux.org/live/current/. Make sure you download the correct ISO for your CPU architecture. Most computers are x86_64 so you’ll most likely have to download void-live-x86_64-20xxxxxx-base.iso. You can use the musl ISO if you want the musl C library, but for this guide, I will be using the standard glibc ISO. To flash the ISO on Windows, you can use Rufus or Etcher. On macOS and Linux, you can use either Etcher, or the classic dd command as follows:\ncd /path/to/iso\nsudo dd if=void-live-x86_64-20xxxxxx-base.iso of=/dev/&lt;your-disk&gt; status=progress\nAll data will be erased from the USB upon flashing the ISO. Make sure you backup any important data before proceeding. I am not responsible for any potential data loss."
  },
  {
    "objectID": "posts/how-to-install-void-linux-with-encryption/index.html#booting-the-installation-usb",
    "href": "posts/how-to-install-void-linux-with-encryption/index.html#booting-the-installation-usb",
    "title": "How To Install Void Linux with LUKS + KDE + PipeWire (unfinished)",
    "section": "Booting the installation USB",
    "text": "Booting the installation USB\nRestart your PC and press the boot menu key to get into the boot menu. This can vary depending on your BIOS. Consult your motherboard manual or check with your PC manufacturer for the boot menu key. Once you select your USB, you will be prompted to login. For the username, type root. For the password, type voidlinux. You will now be greeted with a terminal prompt."
  },
  {
    "objectID": "posts/how-to-install-void-linux-with-encryption/index.html#installation",
    "href": "posts/how-to-install-void-linux-with-encryption/index.html#installation",
    "title": "How To Install Void Linux with LUKS + KDE + PipeWire (unfinished)",
    "section": "Installation",
    "text": "Installation\n\nConnecting to the Internet\nThe first thing to do is to check if your have internet access. If you’re using an Ethernet cable, you should be good to go. If you are using Wi-Fi, you will have to connect manually. To do this, you must first get the name of your Wi-Fi interface. To do this, type ls /sys/class/net and you should get an output similar to this:\nlo  wlp1s0\nLook for the wlp interface. This interface will be used to connect to the Internet. We will now use wpa_supplicant to connect to Wi-Fi. Type the following commands:\nwpa_passphrase \"&lt;your-wifi-name&gt;\" \"&lt;password&gt;\" &gt;&gt; /etc/wpa_supplicant/wpa_supplicant.conf\nwpa_supplicant -B -i &lt;your-interface&gt; -c /etc/wpa_supplicant/wpa_supplicant.conf\nln -s /etc/sv/wpa_supplicant /var/service\nTo test if it works, type ping -c 3 voidlinux.org and if your output is similar as shown below, you’re good to go.\nPING voidlinux.org (2606:50c0:8000::153) 56 data bytes\n64 bytes from 2606:50c0:8000::153: icmp_seq=1 ttl=56 time=19.5 ms\n64 bytes from 2606:50c0:8000::153: icmp_seq=2 ttl=56 time=34.5 ms\n64 bytes from 2606:50c0:8000::153: icmp_seq=3 ttl=56 time=34.0 ms\n\n--- voidlinux.org ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2003ms\nrtt min/avg/max/mdev = 19.466/29.298/34.468/6.955 ms\n\n\nPartitioning the disk\nNow it is time to partition the disk. For this guide, I will be assuming that the entire disk will be used. The first think to do is check your disk layout. type lsblk and you should see a list of disks along with their capacity. If you have a SATA disk, you’ll most likely see sda, sdb, sdc, etc. If you have an NVMe disk, you’ll most likely see nvme0n1, nvme0n2, nvme1n1, nvme1n2, etc."
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Posts",
    "section": "",
    "text": "Date\n\n\n\nTitle\n\n\n\nAuthor\n\n\n\n\n\n\n\n\nAug 7, 2025\n\n\nSetting up Kubernetes with custom image support on Alpine Linux\n\n\nSantiago Torres\n\n\n\n\n\n\nJul 27, 2025\n\n\nHow To Install Void Linux with LUKS + KDE + PipeWire (unfinished)\n\n\nSantiago Torres\n\n\n\n\n\n\nApr 7, 2025\n\n\nHow I Got Into Linux\n\n\nSantiago Torres\n\n\n\n\n\n\nApr 7, 2025\n\n\nHow To Setup QEMU/Virt Manager On Linux\n\n\nSantiago Torres\n\n\n\n\n\n\nApr 5, 2025\n\n\nDecoding a UTF-8 Hex String Into It’s Unicode Code Print\n\n\nSantiago Torres\n\n\n\n\n\n\nNo matching items"
  }
]